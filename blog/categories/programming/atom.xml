<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: programming | Ramblin's]]></title>
  <link href="http://cmr.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://cmr.github.io/"/>
  <updated>2013-10-21T19:05:53-04:00</updated>
  <id>http://cmr.github.io/</id>
  <author>
    <name><![CDATA[Corey Richardson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[On Stack Safety]]></title>
    <link href="http://cmr.github.io/blog/2013/10/21/on-stack-safety/"/>
    <updated>2013-10-21T00:42:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/21/on-stack-safety</id>
    <content type="html"><![CDATA[<p>Stack safety is a sticky topic in Rust right now. There are multiple
conflicting tensions. My goal is to lay them bare, untangle the mess, and see
if there&rsquo;s a better way forward (spoiler: there is!).</p>

<!-- more -->


<p>When a program is &ldquo;stack safe&rdquo;, the <a href="http://en.wikipedia.org/wiki/Call_stack#Structure">stack
pointer</a> never points
outside of allocated memory specifically dedicated to the stack. The
most interesting violation of stack safety as it applies to Rust is the <a href="http://en.wikipedia.org/wiki/Stack_overflow">stack
overflow</a>. (In fact, given
safe code, or even unsafe code as long as it doesn&rsquo;t putz with the stack
pointer or the stack frame, it is the <em>only</em> possible violation of stack
safety). Stack overflow happens when the stack does not have enough space to
store the full stack frame.</p>

<p>There are three basic ways of dealing with stack overflow:</p>

<ol>
<li>Give up and accept the potential memory unsafety and resulting bugs.</li>
<li>Do static analysis to determine the maximum stack size, and make sure
that the stack is at least that large.</li>
<li>Do runtime checks to make sure that there is always enough space on the
stack for a function to proceed, and handle violation of that condition
somehow.</li>
</ol>


<p>(<em>Note</em>: in what follows, I conflate &ldquo;language&rdquo; with &ldquo;implementation of a
given language&rdquo; for clarity)</p>

<p>Examples of languages that take strategy #1 are C, C++, Nimrod, and
Objective-C. Stack overflow usually manifests as a segmentation fault or bus
error, though more colorful errors are possible when a thread runs into
another thread&rsquo;s stack, or onto the heap, causing heap corruption or threads
stomping on each others' stack. Clearly this is not a viable solution for
Rust: the very act of calling a function becomes unsafe.</p>

<p>Strategy #2 is tempting, but cannot be used in the general case. The
<a href="http://dl.acm.org/citation.cfm?id=1113833&amp;bnc=1">research</a>
<a href="http://dl.acm.org/citation.cfm?id=1631721">I</a>
<a href="http://dl.acm.org/citation.cfm?doid=1375634.1375656">found</a> investigate stack
depth in the case of no recursion (so the call graph is actually a call
(directed-)acyclic graph) but with asynchronous interrupt handlers. Indeed,
it&rsquo;s trivial to show that when recursion is disallowed, a conservative stack
limit can be calculated just by taking the longest path through the call graph
with the nodes being weighted by the size that function&rsquo;s stack frame needs
(this is a slightly different construction than most weighted graphs). This
solution is not viable either: recursion is perfectly valid, rejecting it
would make Rust very crippled as a language. To my knowledge, no languages
rely on this for stack safety, though in practice I am sure many applications
apply this technique.</p>

<p>This leaves us with strategy #3, dynamic checks. Dynamic checking is fairly
easy to do. The size of a function&rsquo;s stack frame is easy to calculate. One
need only increment/decrement some global (or, rather, thread-local) counter
by the stack frame size. When it becomes negative, there is no more stack.
Almost every language I&rsquo;ve used (the exceptions are noted above) use this
technique. Java, Python, Lua, Ruby, Go, the list goes on. The only differences
between the languages is what they do when the stack does overflow. Most throw
an exception. Another method of implementing dynamic checks is to leave a
&ldquo;guard zone&rdquo; after the stack. This zone is mapped in a way that accessing it
causes a page fault, which sends a signal or kills the process. (The exact
implementation of this strategy differs; some allocate a stack frame for a
function on the heap. Things get blurry with the interpreted languages, but
they generally prevent stack overflow in a memory safe way.)</p>

<p>Rust currently uses strategy #3, with tweaks. The current implementation
heavily depends on LLVM&rsquo;s <a href="http://llvm.org/releases/3.0/docs/SegmentedStacks.html">segmented
stack</a> feature. On x86
(and I assume other platforms as well), a pointer to the end of the stack is
stored in thread-local storage. The prelude to every function call compares
that value to the value of the stack pointer, and calls a special function
<code>__morestack</code> which will allocate a new stack segment for the function call to
take place on. The stack segment is freed afterwards. The kink comes when
using the FFI to call C code. C assumes a single, large stack. In order to
fulfill that expectation, we have the <code>fixed_stack_segment</code> attribute to
give a function a large stack segment: hopefully large enough that the C
function doesn&rsquo;t overflow the stack.</p>

<p>Segmented stacks are of questionable utility. On large systems, such as x64,
address space is practically boundless, so lazily allocating stack segments is
going to be slower than just requesting a very large mmap&rsquo;d stack that the OS
will lazily allocate. On small, resource-constrained systems, the overhead of
stack size checking (it requires TLS <em>and</em> stack size checks) is too much.
Segmented stacks only optimize for mid-sized address spaces. And the entire
purpose of segmented stacks (conservative but growable stack sizes) is moot if
one is not using many tasks with small stacks.
(<a href="https://mail.mozilla.org/pipermail/rust-dev/2013-July/004686.html">Previously</a>,
<a href="https://github.com/mozilla/rust/issues/8345">previously</a>)</p>

<p>All of the solutions so far are inadequate. They&rsquo;re inflexible and have poor
composability in the case where a crate wants custom stack safety. I propose a
hybrid:</p>

<ol>
<li>If there is no recursion or other sources of stack size uncertainty, the
maximum stack size is decidable and is used as the only stack size, like
strategy #2. Every function would be annotated with the total stack size it
could possibly use, given static function calls. This fails at the first
introduction of function pointers: it is impossible to know how much stack
they need until runtime. However, this is not as limiting as it may sound,
as long as one only tries to achieve a conservative estimate of maximum
stack size. Since function pointers only come from trait objects and
closures, the compiler can take the max of the stack frame for <em>every
implemention</em> of the trait. I would assume closures could work in a similar
way, in limited cases. There will always be cases where this analysis
fails.</li>
<li>If the analysis in step 1 results in indeterminate stack sizes, rustc will
check a crate attribute. This crate attribute indicates which stack safety
strategy should be used: either guard zones, stack size checks, segmented
stacks, or no stack safety at all (note that stack size checks is segmented
stacks minus expanding the stack with <code>__morestack</code>).  Disabling stack
safety &ldquo;taints&rdquo; a crate, and any use of its functions requires <code>unsafe</code>,
like calling C code, and they cannot be coerced to closures (this would
lose the &ldquo;taint&rdquo; bit). Note that when the maximum stack size is decidable,
this attribute won&rsquo;t be checked.</li>
</ol>


<p>All of the trickiness comes from compiling libraries with this. Executables
are easy: since they define the execution context, they can decide how they
want the stack to be secured. Libraries, being embedded in other contexts,
need to obey their execution environment. At the very least, no-stack-safety
will make it possible to implement libraries exposing a native ABI in Rust
without requiring weirdness in the FFI, as well as implement custom stack
safety when it&rsquo;s desired.</p>

<p>By allowing crates to chose how they want stack safety to be implemented, we
retain flexibility to fit any situation. By making it a crate attribute, we
can handle combination of crates using different stack safety schemes in a
sane way. There are still some niggling details with combining crates using
different stack safety schemes (propagating the taint bit is quite difficult
in the face of trait objects, but for now we could simply disallow
combinations and work them out later (it&rsquo;s a backwards compatible change). I
think this is a good stack safety strategy, superior to the current one, and
worth implementing.</p>

<p>Please email me any comments, or see the <a href="http://www.reddit.com/r/rust/comments/1owhwi/on_stack_safety/">discussion on
reddit</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM ICPC: What I Learned]]></title>
    <link href="http://cmr.github.io/blog/2013/10/20/acm-icpc-what-i-learned/"/>
    <updated>2013-10-20T10:47:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/20/acm-icpc-what-i-learned</id>
    <content type="html"><![CDATA[<p>Yesterday I participated in my first <a href="http://icpc.baylor.edu/">programming
contest</a>. It was very fun, though challenging, and I
learned a fair bit during it. <!-- more --> The content consisted of teams of
3 working to solve 6 problems as fast as possible. The problems ranged from
trivial (repeated arithmetic) to moderately complex.</p>

<h2>Problem solving is fun.</h2>

<p>I already knew this, but it has been some time since I&rsquo;ve done intense
problem solving. It was nice to sit down for a few hours and bang my head
on a problem. Creative problem solving just <em>feels</em> good, in a way that most
activities don&rsquo;t.</p>

<h2>I don&rsquo;t know much about algorithms or data structures</h2>

<p>Of course I know the basic search and sorts, but anything involving
anything more complex than binary trees is beyond my current knowledge. A
few of the problems were solved very elegantly with tree operations. I was
unable to come up with a way to express the operation I wanted to perform.
It&rsquo;s a <a href="http://en.wikipedia.org/wiki/Longest_path_problem">standard problem</a>
which I had not been aware of.</p>

<p>Now that I <a href="http://en.wikipedia.org/wiki/There_are_known_knowns">know what I don&rsquo;t
know</a>, I can expand my
knowledge.</p>

<h2>C++&rsquo;s iostreams are quite nice</h2>

<p>Previously I haven&rsquo;t been a fan of iostreams, due to their misplaced
pedagogical use. But, for simply reading whitespace-separated data from stdin
and outputting the same to stdout, there probably isn&rsquo;t anything easier. I
might implement something similar (though not using the <code>&gt;&gt;</code> and <code>&lt;&lt;</code>
operators).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[This Week in Rust]]></title>
    <link href="http://cmr.github.io/blog/2013/10/19/this-week-in-rust/"/>
    <updated>2013-10-19T10:49:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/19/this-week-in-rust</id>
    <content type="html"><![CDATA[<p>Welcome to another issue of <em>This Week in Rust</em>, a weekly summary of Rust&rsquo;s
progress and happenings in the community.</p>

<!-- more -->


<h1>What&rsquo;s cooking in master?</h1>

<p>48 PRs were merged this week.</p>

<h2>Breaking changes</h2>

<ul>
<li>Slices are now represented as <a href="https://github.com/mozilla/rust/pull/9885">number of elements, not number of
bytes</a>.</li>
<li><code>fmt!</code> has been <a href="https://github.com/mozilla/rust/pull/9919">completely
removed</a>.</li>
<li>Some fields in <code>std::comm</code> <a href="https://github.com/mozilla/rust/pull/9935">have been made
private</a>.</li>
<li><code>std::sys::refcount</code> <a href="https://github.com/mozilla/rust/pull/9922">has been
moved</a> to
<code>std::managed::refcount</code>.</li>
<li><a href="https://github.com/mozilla/rust/pull/9896/files#diff-69196c6d2488bf8d5b3471084e854407L22">A bunch of
functions</a>
have moved from <code>std::sys</code> to <code>std::mem</code>.</li>
<li><code>once fn</code> is <a href="https://github.com/mozilla/rust/pull/9863">now a feature gate</a>
rather than a <code>-Z</code> flag.</li>
<li><code>Path</code> has been <a href="https://github.com/mozilla/rust/pull/9655">completely
rewritten</a>.</li>
<li><code>extra::flatpipes</code> <a href="https://github.com/mozilla/rust/pull/9886">has been
removed</a>.</li>
</ul>


<h2>Other changes</h2>

<ul>
<li><code>jemalloc</code> has been <a href="https://github.com/mozilla/rust/pull/9933">removed from the
runtime</a>. The <a href="https://github.com/mozilla/rust/issues/9925">associated
issue</a> is quite scary.</li>
<li><code>rustdoc</code> <a href="https://github.com/mozilla/rust/pull/9946">struct field
visibility</a> is now corrected (it
stripped fields where it should not have).</li>
<li><code>rustdoc</code> also <a href="https://github.com/mozilla/rust/pull/9941">uses the actual privacy
rules</a> to strip methods.</li>
<li><code>format!</code> now gives <a href="https://github.com/mozilla/rust/pull/9932">much better</a>
error messages for invalid format strings.</li>
<li>The <code>fmt::Default</code> trait, used for default formatting with <code>format!</code>, is
<a href="https://github.com/mozilla/rust/pull/9938">now documented</a>.</li>
<li><code>include_bin!</code> has been optimized, and the <code>k-nucleotides</code> benchmark now
compiles <a href="https://github.com/mozilla/rust/pull/9851">187x faster</a>.</li>
<li>Vectors now have <a href="https://github.com/mozilla/rust/pull/9907"><code>starts_with</code> and <code>ends_with</code>
methods</a>, which take slices.</li>
<li>An <code>abort</code> intrinsic <a href="https://github.com/mozilla/rust/pull/9860">has been
added</a>.</li>
<li>Vectors now have a <a href="https://github.com/mozilla/rust/pull/9608"><code>get_opt</code>
method</a>.</li>
</ul>


<h2>New contributors</h2>

<p>A new section for new contributors! The new contributors this week are (as
reported by git):</p>

<ul>
<li>Chris Sainty</li>
<li>Eduard Burtescu</li>
<li>Erik Lyon</li>
<li>Harry Marr</li>
<li>Sébastien Chauvel</li>
<li>Vijay Korapaty</li>
<li>Ziad Hatahet</li>
<li>chitra</li>
</ul>


<h1>Weekly Meeting</h1>

<p>The <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-10-15">weekly
meeting</a>
discussed removing rusti, changing the attribute syntax, destructors in
statics, and more multi-crate packages with rustpkg.</p>

<h1>Announcements etc</h1>

<ul>
<li>Rust (and Servo) are participating in the <a href="https://groups.google.com/forum/#!topic/mozilla.dev.servo/7kX_E0FlfkA">GNOME Outreach Program for
Women</a>.
A bunch of people have already come into IRC about it.</li>
<li><a href="http://exercism.io">http://exercism.io</a> <a href="https://github.com/kytrinyx/exercism.io/pull/866">is getting full Rust
support</a>. This is a very
cool resource, and could help a lot getting newcomers acclimated.</li>
<li><a href="https://mail.mozilla.org/pipermail/rust-dev/2013-October/006034.html">Unified Function/method Call Syntax and further
simplification</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1osbq2/safe_manual_memory_management_in_cyclone_research/">Safe Memory Management in
Cyclone</a>.</li>
<li><a href="http://opensourcebridge.org/sessions/970">Audio</a> from Tim&rsquo;s talk in June is
finally available!</li>
<li>An
<a href="https://github.com/mozilla/rust/wiki/Operating-system-development">OSdev</a>
community has sprung up! The channel is <code>#rust-osdev</code>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1omw47/should_io_use_conditions/">Should I/O use
conditions?</a>.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1opo36/pointers_in_rust_a_guide/">Pointers in Rust: A
Guide</a>.</li>
<li>I am on a <a href="http://cmr.github.io/blog/2013/10/14/rust-hiatus/">Rust hiatus</a>,
for the time being. TWiR will still be happening, as you are reading it
right now.</li>
<li><a href="https://github.com/thestinger/rust-core">rust-core</a> &ndash; A stub standard
library.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[This Week in Rust]]></title>
    <link href="http://cmr.github.io/blog/2013/10/12/this-week-in-rust/"/>
    <updated>2013-10-12T22:53:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/12/this-week-in-rust</id>
    <content type="html"><![CDATA[<p>Welcome to another issue of <em>This Week in Rust</em>. This week introduces raw
string literals, the removal of the <code>rust</code> tool, feature gating, and the
privacy overhaul.</p>

<!-- more -->


<h1>What&rsquo;s cooking on master?</h1>

<p>Only 51 PRs were merged this week, though the ones that were were fairly
large.</p>

<h2>Breaking changes</h2>

<ul>
<li>Visibility and privacy have been defined, and the new semantics are slightly
incompatible with the old. The details are
<a href="https://github.com/mozilla/rust/pull/9735">here</a>.</li>
<li>Feature gating has been <a href="https://github.com/mozilla/rust/pull/9703">added to the
compiler</a>. This allows us to
mask language features that we don&rsquo;t want to commit to for 1.0. The compiler
will tell you when you are using an &ldquo;experimental&rdquo; feature. The current
experimentals are glob imports, macro definitions, and struct-like variants
in enums. This is an important step forward for 1.0 which,
<a href="http://www.reddit.com/r/rust/comments/1o90f9/fn_types_in_rust_take_3/ccq8qev">apparently</a>,
is right around the corner.</li>
<li>The <code>rust</code> tool <a href="https://github.com/mozilla/rust/pull/9785">has been
removed</a>.</li>
<li><code>Option</code>&rsquo;s API has been <a href="https://github.com/mozilla/rust/pull/9359">massively
simplified</a>, and changed to be
composable.</li>
<li>Strings are <a href="https://github.com/mozilla/rust/pull/9750">no longer allowed to be modified in safe
code</a>. Things like <code>let s =
~"abcdefg"; s[4] = 0x99;</code> are now rejected. This is because it allows one to
create invalid (non-UTF8) string values.</li>
<li><code>extra::rc</code> has <a href="https://github.com/mozilla/rust/pull/9794">graduated to
<code>std::rc</code></a>.</li>
<li><code>extra::tempfile::mkdtemp</code> <a href="https://github.com/mozilla/rust/pull/9802">has been replaced with an RAII
wrapper</a>.</li>
<li><code>std::rand</code> <a href="https://github.com/mozilla/rust/pull/9695">has been improved</a>,
but changes the public API of Rng a bit.</li>
<li><code>IntConvertible</code> has been removed in favor of <a href="https://github.com/mozilla/rust/pull/9250"><code>ToPrimitive</code> and
<code>FromPrimitive</code></a>, which can be
derived for enums, making interacting with C APIs substantially more
<a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>.</li>
</ul>


<h2>Other changes</h2>

<ul>
<li><a href="https://github.com/mozilla/rust/pull/9674">Raw strings</a> are now supported.
The basic syntax is <code>r"Foo"</code>, but also <code>r###"Foo"###</code>, for arbitrary
nesting of raw strings.</li>
<li>rustpkg&rsquo;s remote fetching <a href="https://github.com/mozilla/rust/pull/9741">is
fixed</a>, but <a href="https://github.com/mozilla/rust/issues/9482">other
</a>
<a href="https://github.com/mozilla/rust/issues/9781">problems</a> prevent it from
being fully usable right now.</li>
<li>debuginfo namespace handling <a href="https://github.com/mozilla/rust/pull/9658">has been
unified</a>, and marks the ability
to build all of Rust (libstd, libextra, compiler and tools) with debuginfo,
which is very awesome.</li>
<li>Small structs <a href="https://github.com/mozilla/rust/pull/9759">are immediate</a>.</li>
<li>When there are unbalanced delimiters, <a href="https://github.com/mozilla/rust/pull/9756">the opening delimiters leading up to
it</a> are printed, avoiding the
&ldquo;Expected a }, saw EOF at line 9001&rdquo; problem.</li>
<li>libuv and jemalloc are only <a href="https://github.com/mozilla/rust/pull/9772">built once, rather than once per
stage</a>.</li>
<li>Macros <a href="https://github.com/mozilla/rust/pull/9753">now take attributes</a> and,
in turn, can be documented.</li>
<li>In the opposite direction, <a href="https://github.com/mozilla/rust/pull/9783">macros can now expand to items with
attributes</a>.</li>
<li>There were some <a href="https://github.com/mozilla/rust/pull/9664">minor logging
changes</a>, the biggest result of
which is that inlined functions won&rsquo;t be logged by the modules they&rsquo;re
inlined into.</li>
<li><a href="https://github.com/mozilla/rust/pull/9749"><code>std::rt::io::native</code> has been
implemented</a>. The idea of this is
to live in <code>std::io::native</code> and to use the OS&rsquo;s native APIs rather than
libuv, and also to not require the scheduler or any other runtime support.</li>
<li>rustpkg <a href="https://github.com/mozilla/rust/pull/9732">marks checked out repos as
read-only</a>, to prevent
modifications.</li>
</ul>


<h1>Weekly Meeting</h1>

<p>The <a href="https://github.com/mozilla/rust/wiki/Meeting-weekly-2013-10-08">weekly
meeting</a>
discussed some administrative things, the removal of crypto code, the removal
of the <code>rust</code> tool, and functions.</p>

<h1>Announcements etc</h1>

<ul>
<li><a href="http://www.reddit.com/r/rust/comments/1o35ns/fuse_userspace_library_in_rust/">rust-fuse</a>
- a FUSE userspace library in Rust. This is pure Rust, not using libfuse.</li>
<li><a href="http://www.reddit.com/r/rust/comments/1o46cv/ears_a_simple_library_for_playing_sounds/">ears</a>
- a simple library for playing sounds.</li>
<li><a href="https://github.com/pcmattman/rustic">rustic</a> &ndash; another operating system
project.</li>
<li><a href="https://mail.mozilla.org/pipermail/rust-dev/2013-October/005981.html">Refactoring the milestones on the issue
tracker</a>.</li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2013/10/10/fn-types-in-rust/">Fn Types in Rust, Take
3</a>
- another attempt at tackling the problems with closures.</li>
<li>mcpherrin in <code>#rust</code> says &ldquo;Hello, everyone!&rdquo;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The State of Rust 0.8]]></title>
    <link href="http://cmr.github.io/blog/2013/10/06/the-state-of-rust-0-dot-8/"/>
    <updated>2013-10-06T20:32:00-04:00</updated>
    <id>http://cmr.github.io/blog/2013/10/06/the-state-of-rust-0-dot-8</id>
    <content type="html"><![CDATA[<p>Another 3 months, another release. This is the first release that I&rsquo;ve
witnessed in its entirety! This is a summary of Rust: its compiler,
libraries, documentation, and community. (<a href="http://rust-lang.org">What is
Rust?</a>)</p>

<!-- more -->


<h1>Compiler</h1>

<p>The compiler is faring well. It received a lot of attention in compile speed,
although memory usage regressed significantly. It is now mostly fixed in
master. Time compiling <code>fn main() { }</code> went from 172ms to 112ms on my box.
When compiling programs of any significance, the gap is much larger. There&rsquo;s
also been some thought put into parallelizing rustc. Michael Woerister&rsquo;s GSoC
project was debuginfo, and it&rsquo;s almost in a fully-working state. As of 0.8,
it&rsquo;s not completely baked &mdash; libstd can&rsquo;t be compiled with it, and stepping
through code isn&rsquo;t perfect &mdash; but it&rsquo;s a huge step forward, and he created an
extensive testsuite, so it shouldn&rsquo;t regress. The pretty printer hasn&rsquo;t seen
much improvement. Default methods, one of the major things Michael Sullivan
worked on over the summer, are in a much better state. If there are any
remaining bugs in them, I haven&rsquo;t seen them.</p>

<h1>Iterators</h1>

<p>Iterators are hugely improved for 0.8. The <code>for</code> loop syntax now uses the
Iterator trait. Additionally, most uses of vector iterators now compile to the
exact same code that indexing or iteration would in C or C++, including the
ability to be vectorized. Additionally, they now use default methods instead
of extension implementations. A bunch of other extensions to Iterator were
added, such as DoubleEndedIterator and RandomAccessIterator.</p>

<h1>Documentation</h1>

<p>The documentation is in a much better state than it was 3 months ago. The new
rustdoc was started and finished. I started it, and Alex Crichton really
polished and finished it the last two weeks before the release. The API
documentation is now navigable, and one can actually see the relationship
between various types. A bunch of work also went into the tutorials, yielding
three new documents: error handling and conditions, iterators and containers,
and rustpkg.</p>

<h1><code>rustpkg</code></h1>

<p>Rustpkg continues to advance. Tim put out the call for community involvement,
and it&rsquo;s getting significant traction in actual libraries. There are still a
few kinks when using it for development, but when just fetching and building
dependencies, it works very well. Servo is porting its whole mini-ecosystem
over to rustpkg, uncovering bunches of problems and deficiencies in the
process. If you&rsquo;re interested in helping out with Rust, rustpkg is a major
area. Tim is also super nice, and will happily help you get into the codebase.</p>

<h1>Libraries</h1>

<p>Rust is slowly accreting more and more useful libraries: mostly coming from
the gamedev community, but sometimes other useful things as well. The
new runtime has completely replaced the old, a significant step forward for
Rust&rsquo;s maturity. <code>rust-http</code> is making some really nice strides, as well as
the opengl bindings. The standard libraries are becoming nicer to use.
<code>std::run</code>, in particular, stands out to me as something that&rsquo;s quite easy to
use, and <code>std::str</code> saw a lot of work making it more correct.</p>

<h1>The Future</h1>

<p>This was a great release cycle, and I think the next one will be even better.
Alex Crichton was hired as a full-time Rust developer, and he has been doing a
lot of important work that just would have taken a while to happen otherwise.
I&rsquo;m very optimistic about this release, much more so than 0.7. I think we
might be able to hit milestone 1 for 0.9 or 0.10, though that&rsquo;s just
speculation on my part.</p>

<h1>Is Rust Ready?</h1>

<p>No. Rust is approaching maturity, but it isn&rsquo;t there yet. There are still
backwards-incompatible changes being made to try and get to milestone 2.  The
major things that come to mind are closure reform and privacy overhaul (which
is being worked on in master <a href="https://github.com/mozilla/rust/pull/9735">right
now</a>). Additionally, people in the
gamedev community are starting to <a href="http://www.reddit.com/r/rust/comments/1nxs1h/the_state_of_rust_08/ccnb8ya">hit walls with the type
system</a>.
Those probably won&rsquo;t be fixed in the time leading up to 1.0, but this is also
speculation.</p>

<p>Experimenting with Rust is becoming more viable as time goes on, but using it
in production is a bad idea, especially if &ldquo;low maintenance&rdquo; is at all
valuable.</p>
]]></content>
  </entry>
  
</feed>
